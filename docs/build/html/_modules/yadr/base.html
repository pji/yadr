<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>yadr.base &mdash; yadr 0.1.2 documentation</title>
      <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="../../" id="documentation_options" src="../../_static/documentation_options.js"></script>
        <script src="../../_static/doctools.js"></script>
        <script src="../../_static/sphinx_highlight.js"></script>
    <script src="../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../index.html" class="icon icon-home">
            yadr
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../index.html">Welcome to yadrâ€™s documentation!</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../dice_notation.html">YADN</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../requirements.html">yadr Requirements</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../internals.html"><code class="xref py py-mod docutils literal notranslate"><span class="pre">yadr</span></code> Internals</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">yadr</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../index.html">Module code</a></li>
      <li class="breadcrumb-item active">yadr.base</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for yadr.base</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">base</span>
<span class="sd">~~~~</span>

<span class="sd">Base classes for the :mod:`yadr` package.</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="kn">from</span> <span class="nn">abc</span> <span class="kn">import</span> <span class="n">ABC</span><span class="p">,</span> <span class="n">abstractmethod</span>
<span class="kn">from</span> <span class="nn">collections.abc</span> <span class="kn">import</span> <span class="n">Callable</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Optional</span>

<span class="kn">from</span> <span class="nn">yadr.model</span> <span class="kn">import</span> <span class="n">CompoundResult</span><span class="p">,</span> <span class="n">Result</span><span class="p">,</span> <span class="n">Token</span><span class="p">,</span> <span class="n">TokenInfo</span>


<span class="c1"># Types</span>
<span class="n">ResultMethod</span> <span class="o">=</span> <span class="n">Callable</span><span class="p">[[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Result</span><span class="p">]</span>
<span class="n">StateMethod</span> <span class="o">=</span> <span class="n">Callable</span><span class="p">[[</span><span class="nb">str</span><span class="p">],</span> <span class="kc">None</span><span class="p">]</span>


<span class="c1"># Utility functions.</span>
<span class="k">def</span> <span class="nf">_mutable</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">type_</span><span class="o">=</span><span class="nb">list</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Return an empty mutable type to avoid bugs where you put a</span>
<span class="sd">    mutable in the signature.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">value</span><span class="p">:</span>
        <span class="n">value</span> <span class="o">=</span> <span class="n">type_</span><span class="p">()</span>
    <span class="k">return</span> <span class="n">value</span>


<span class="c1"># Base classes.</span>
<div class="viewcode-block" id="BaseLexer"><a class="viewcode-back" href="../../lexing.html#yadr.base.BaseLexer">[docs]</a><span class="k">class</span> <span class="nc">BaseLexer</span><span class="p">(</span><span class="n">ABC</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;An abstract base class for building lexers.</span>

<span class="sd">    :param state_map: A dictionary mapping the state of the lexer</span>
<span class="sd">        to the processing method for that state.</span>
<span class="sd">    :param symbol_map: A dictionary mapping states of the lexer to</span>
<span class="sd">        characters that could occur within the text being lexed.</span>
<span class="sd">    :param bracket_states: (Optional.) A dictionary mapping opening</span>
<span class="sd">        or delimiting states to a state that collects characters</span>
<span class="sd">        within the brackets or delimiters to send to a more</span>
<span class="sd">        specific lexer.</span>
<span class="sd">    :param bracket_ends: (Optional.) A dictionary mapping bracket</span>
<span class="sd">        states to a state that processes characters after the end</span>
<span class="sd">        of the bracket state.</span>
<span class="sd">    :param result_map: (Optional.) A dictionary mapping states</span>
<span class="sd">        to a result transformation method to transform the data</span>
<span class="sd">        in the lexed string before storing it in as a token</span>
<span class="sd">        value.</span>
<span class="sd">    :param no_store: (Optional.) A list of states that should not</span>
<span class="sd">        be stored as tokens.</span>
<span class="sd">    :param init_state: (Optional.) The initial state of the lexer.</span>
<span class="sd">        It defaults to :class:`Token.START`.</span>
<span class="sd">    :return: None.</span>
<span class="sd">    :rtype: NoneType</span>

<span class="sd">    :class:`yadr.base.BaseLexer` lexers are state machines used for</span>
<span class="sd">    translating a text string into tokens for parsing. It accomplishes</span>
<span class="sd">    this by processing the string one character at a time, allowing the</span>
<span class="sd">    current state of the lexer to determine whether the character is</span>
<span class="sd">    legal and what should be done with it.</span>


<span class="sd">    State</span>
<span class="sd">    -----</span>
<span class="sd">    The current state of the lexer is determined by the value of</span>
<span class="sd">    :attr:`yadr.base.BaseLexer.state`. Its value will be a member</span>
<span class="sd">    of the enumeration used to define the tokens that exist within</span>
<span class="sd">    the language. This state is used to define the rule used to</span>
<span class="sd">    process the next character in the string.</span>

<span class="sd">    Characters that do not cause the state of the lexer to change</span>
<span class="sd">    should be appended to the end of the `buffer` attribute of</span>
<span class="sd">    the lexer.</span>


<span class="sd">    State Change</span>
<span class="sd">    ------------</span>
<span class="sd">    When the lexer encounters a character that represents the end of</span>
<span class="sd">    the previous token and the start of a new token, the state of</span>
<span class="sd">    the lexer changes. The specific details can vary based on the</span>
<span class="sd">    current state of the lexer, but by default the following occurs</span>
<span class="sd">    when the state is changed:</span>

<span class="sd">    *   A new :class:`model.TokenInfo` object is created that contains</span>
<span class="sd">        the current state of the lexer and the current value of the</span>
<span class="sd">        `buffer` attribute of the lexer.</span>
<span class="sd">    *   That :class:`model.TokenInfo` object is appended to the `tokens`</span>
<span class="sd">        attribute of the lexer.</span>
<span class="sd">    *   The `buffer` of the lexer is cleared.</span>
<span class="sd">    *   The `state` of the lexer is changed to the new state.</span>
<span class="sd">    *   The :meth:`BaseLexer.process` method is changed to the process</span>
<span class="sd">        method for the new state.</span>


<span class="sd">    :meth:`BaseLexer.process()` and Processing Methods</span>
<span class="sd">    --------------------------------------------------</span>
<span class="sd">    The :meth:`BaseLexer.process` method of a :class:`BaseLexer`</span>
<span class="sd">    subclass should not be defined. Instead the name should be</span>
<span class="sd">    assigned to a &quot;processing&quot; method specific to the current state</span>
<span class="sd">    of the lexer. By convention, the names of these method starts</span>
<span class="sd">    with an underscore, which is followed by the name of the state in</span>
<span class="sd">    lowercase letters. So the processing method for the state::</span>

<span class="sd">        Token.GROUP_OPEN</span>

<span class="sd">    would be::</span>

<span class="sd">        _group_open</span>

<span class="sd">    The signature for processing methods are::</span>

<span class="sd">        (self, char: str) -&gt; None</span>

<span class="sd">    where `char` is the character being processed.</span>

<span class="sd">    While specific tokens may require different behavior, in general</span>
<span class="sd">    a processing method does two things:</span>

<span class="sd">    *   Define a list of states that are allowed to follow the</span>
<span class="sd">        current state within the syntax being lexed.</span>
<span class="sd">    *   Pass that list and the character to :meth:`BaseLexer._check_char`,</span>
<span class="sd">        which handles the actual processing.</span>

<span class="sd">    The end result of calling a processing method is usually that</span>
<span class="sd">    the characters in the string that make up the symbol for the</span>
<span class="sd">    current state are stored in a &quot;TokenInfo&quot; :class:`tuple`, which</span>
<span class="sd">    consists of the token representing the state and the characters of</span>
<span class="sd">    the symbol. These tokens will then be used by the parser to</span>
<span class="sd">    execute the command contained in the string.</span>


<span class="sd">    The State Map</span>
<span class="sd">    -------------</span>
<span class="sd">    To determine the correct processing method to use for a state, the</span>
<span class="sd">    lexer needs to have a mapping that defines the method for the state.</span>
<span class="sd">    This dictionary is the &quot;state map.&quot; The tokens for the state are</span>
<span class="sd">    the keys, and the processing method for that state is the value</span>
<span class="sd">    for the key. This dictionary is passed into the :class:`BaseLexer`</span>
<span class="sd">    as the `state_map` parameter when the lexer is initialized.</span>


<span class="sd">    The Symbol Map</span>
<span class="sd">    --------------</span>
<span class="sd">    A BaseLexer uses a &quot;symbol map&quot; to associate characters in the</span>
<span class="sd">    string to a state. The symbol map is a dictionary. The keys are</span>
<span class="sd">    the tokens from the enumeration that defines state. The values</span>
<span class="sd">    are a list of the strings that are allowed in that state. For</span>
<span class="sd">    example, if you have a token named &quot;MULDIV&quot; that is the state for</span>
<span class="sd">    multiplication and division operators, the symbol map might look</span>
<span class="sd">    like::</span>

<span class="sd">        &gt;&gt;&gt; state_map = {</span>
<span class="sd">        &gt;&gt;&gt;     Token.MULDIV: [&#39;*&#39;, &#39;/&#39;],</span>
<span class="sd">        &gt;&gt;&gt; }</span>

<span class="sd">    The symbol map is passed to the `symbol_map` parameter when the</span>
<span class="sd">    lexer is initialized.</span>


<span class="sd">    Bracketing</span>
<span class="sd">    ----------</span>
<span class="sd">    Instead of running each character through</span>
<span class="sd">    :class:`BaseLexer._check_char`, it is possible</span>
<span class="sd">    for a processing method to instead &quot;bracket&quot; characters</span>
<span class="sd">    until a specific character is reached. For example, characters</span>
<span class="sd">    after a quotation mark can be collected as a substring until</span>
<span class="sd">    the lexer hits another quotation mark.</span>

<span class="sd">    Why do this? The main use for this is to turn the bracketed</span>
<span class="sd">    substring into a single token, rather than three tokens: the</span>
<span class="sd">    opening bracket/delimiter, the content of the bracket, and the</span>
<span class="sd">    closing brack/delimiter.</span>

<span class="sd">    To expand on the quotation marks example above, let&#39;s characters</span>
<span class="sd">    surrounded by quotation marks to belong to a token called</span>
<span class="sd">    &quot;QUALIFIER&quot;. We have the following enumeration of states and</span>
<span class="sd">    a `symbol_map` that defines which characters belong to which</span>
<span class="sd">    states::</span>

<span class="sd">        &gt;&gt;&gt; from enum import auto, Enum</span>
<span class="sd">        &gt;&gt;&gt; class Token(Enum):</span>
<span class="sd">        &gt;&gt;&gt;     QUALIFIER = auto()</span>
<span class="sd">        &gt;&gt;&gt;     DELIM = auto()</span>
<span class="sd">        &gt;&gt;&gt;     QUALIFIER_END = auto()</span>
<span class="sd">        &gt;&gt;&gt;</span>
<span class="sd">        &gt;&gt;&gt; symbol_map = {</span>
<span class="sd">        &gt;&gt;&gt;     Token.QUALIFIER: &#39;&#39;,</span>
<span class="sd">        &gt;&gt;&gt;     Token.DELIM: &#39;&quot;&#39;,</span>
<span class="sd">        &gt;&gt;&gt;     QUALIFIER_END: &#39;&#39;,</span>
<span class="sd">        &gt;&gt;&gt; }</span>

<span class="sd">    The string we want to lex is::</span>

<span class="sd">        &gt;&gt;&gt; text = &#39;&quot;spam&quot;&#39;</span>

<span class="sd">    Without a bracket state, you&#39;d end up with a token list that</span>
<span class="sd">    would look like the following, assuming the logic for the</span>
<span class="sd">    QUALIFIER state is written to accept alphabetical characters</span>
<span class="sd">    as valid for qualifiers::</span>

<span class="sd">        &gt;&gt;&gt; (</span>
<span class="sd">        &gt;&gt;&gt;     (Token.DELIM, &#39;&quot;&#39;),</span>
<span class="sd">        &gt;&gt;&gt;     (Token.QUALIFER, &#39;spam&#39;),</span>
<span class="sd">        &gt;&gt;&gt;     (Token.DELIM, &#39;&quot;&#39;),</span>
<span class="sd">        &gt;&gt;&gt; )</span>

<span class="sd">    That&#39;s probably fine, but the delimiter tokens don&#39;t really</span>
<span class="sd">    do anything at this point. They were just there to set out</span>
<span class="sd">    the qualifier in the string. So, you can have them excluded</span>
<span class="sd">    from the token list like the following by using bracketing::</span>

<span class="sd">        &gt;&gt;&gt; (</span>
<span class="sd">        &gt;&gt;&gt;     (Token.QUALIFER, &#39;spam&#39;),</span>
<span class="sd">        &gt;&gt;&gt; )</span>

<span class="sd">    The real power here comes from combining with a result map</span>
<span class="sd">    to send the bracketed content of to a different lexer and</span>
<span class="sd">    parser, which allows syntaxes to be nested within each other.</span>


<span class="sd">    Bracket States</span>
<span class="sd">    --------------</span>
<span class="sd">    To have a processing method bracket, you need to associate</span>
<span class="sd">    the state for the opening bracket or delimiter with a</span>
<span class="sd">    processing method that handles the bracketing in a dictionary</span>
<span class="sd">    passed to the `bracket_states` parameter when initializing the</span>
<span class="sd">    BaseLexer. The `bracket_states` dictionary for the above example</span>
<span class="sd">    would look like this:</span>

<span class="sd">        &gt;&gt;&gt; bracket_state = {</span>
<span class="sd">        &gt;&gt;&gt;     Token.DELIM: Token.QUALIFIER,</span>
<span class="sd">        &gt;&gt;&gt; }</span>


<span class="sd">    Bracket Ends</span>
<span class="sd">    ------------</span>
<span class="sd">    Because a bracket state hides the closing bracket or delimiter</span>
<span class="sd">    from the lexer, you need a different way to handle the state</span>
<span class="sd">    after a bracket state. This is handled by a standard processing</span>
<span class="sd">    method. By convention the name of this method is an underscore</span>
<span class="sd">    followed by the name of the bracket state followed by an</span>
<span class="sd">    underscore and then the word &quot;end&quot;. For our example it would be::</span>

<span class="sd">        _qualifier_end</span>

<span class="sd">    This state needs to have a state token assigned for it. In our</span>
<span class="sd">    example that is the `Token.QUALIFIER_END` token.</span>

<span class="sd">    This end state then needs to be linked to the bracket state in</span>
<span class="sd">    a dictionary that is passed to the `bracket_ends` parameter</span>
<span class="sd">    when initializing the lexer. In the example, the `bracket_ends`</span>
<span class="sd">    dictionary would look like::</span>

<span class="sd">        bracket_ends = {</span>
<span class="sd">            Token.QUALIFIER: Token.QUALIFIER_END,</span>
<span class="sd">        }</span>


<span class="sd">    No Store</span>
<span class="sd">    --------</span>
<span class="sd">    Some states, like the initial state, bracket end states, and</span>
<span class="sd">    white space, shouldn&#39;t be stored as tokens. These are defined</span>
<span class="sd">    by the &quot;no store&quot; list, which is passed to the `no_store`</span>
<span class="sd">    parameter when the lexer is initialized. For the example above,</span>
<span class="sd">    the no store list could look like::</span>

<span class="sd">        &gt;&gt;&gt; no_store = [</span>
<span class="sd">        &gt;&gt;&gt;     Token.QUALIFIER_END,</span>
<span class="sd">        &gt;&gt;&gt; ]</span>


<span class="sd">    Result Transformations</span>
<span class="sd">    ----------------------</span>
<span class="sd">    By default, a :class:`BaseLexer` stores the symbols for the token</span>
<span class="sd">    as a string in the TokenInfo. This behavior can be changed with a</span>
<span class="sd">    &quot;result transformation&quot; method. By convention the name of a</span>
<span class="sd">    result transformation starts with an underscore, the letters &quot;tf&quot;,</span>
<span class="sd">    an underscore, and the name of the state they affect in all lower</span>
<span class="sd">    case. So the name of a result transformation method for the</span>
<span class="sd">    `Token.NUMBER` state would be::</span>

<span class="sd">        _tf_number</span>

<span class="sd">    Result transformations have the following signature::</span>

<span class="sd">        (self, value:str) -&gt; &lt;type_of_the_transformed_value&gt;</span>

<span class="sd">    .. warning:</span>
<span class="sd">        The return type of the result transformation method needs</span>
<span class="sd">        to be added to the types allowed for TokenInfo. This adds</span>
<span class="sd">        complexity that has downstream affects on the parser.</span>

<span class="sd">    In the case of something like `Token.NUMBER` the transformation</span>
<span class="sd">    can be very simple, coercing a string to an integer. However,</span>
<span class="sd">    more complex transformations are possible, such as sending</span>
<span class="sd">    bracketed symbols to a different lexer and parser to allow syntax</span>
<span class="sd">    nesting.</span>


<span class="sd">    Result Map</span>
<span class="sd">    ----------</span>
<span class="sd">    In order to link the result transformation methods to a state,</span>
<span class="sd">    a :class:`BaseLexer` needs a &quot;result map&quot;. The result map is a</span>
<span class="sd">    dictionary. The keys are the states where the transforms are used.</span>
<span class="sd">    The values are the result transformation methods to use for that</span>
<span class="sd">    state. For example, the result map for a lexer that transforms</span>
<span class="sd">    numbers and qualifiers might look like::</span>

<span class="sd">        &gt;&gt;&gt; result_map = {</span>
<span class="sd">        &gt;&gt;&gt;     Token.NUMBER: _tf_number,</span>
<span class="sd">        &gt;&gt;&gt;     Token.QUALIFIER: _qualifier,</span>
<span class="sd">        &gt;&gt;&gt; }</span>

<span class="sd">    The result map is passed to the `result_map` parameter when the</span>
<span class="sd">    :class:`BaseLexer` is initialized.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                 <span class="n">state_map</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="n">Token</span><span class="p">,</span> <span class="n">StateMethod</span><span class="p">],</span>
                 <span class="n">symbol_map</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="n">Token</span><span class="p">,</span> <span class="nb">list</span><span class="p">[</span><span class="nb">str</span><span class="p">]],</span>
                 <span class="n">bracket_states</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">dict</span><span class="p">[</span><span class="n">Token</span><span class="p">,</span> <span class="n">Token</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                 <span class="n">bracket_ends</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">dict</span><span class="p">[</span><span class="n">Token</span><span class="p">,</span> <span class="n">Token</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                 <span class="n">result_map</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">dict</span><span class="p">[</span><span class="n">Token</span><span class="p">,</span> <span class="n">ResultMethod</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                 <span class="n">no_store</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">list</span><span class="p">[</span><span class="n">Token</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                 <span class="n">init_state</span><span class="p">:</span> <span class="n">Token</span> <span class="o">=</span> <span class="n">Token</span><span class="o">.</span><span class="n">START</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Initialize an instance of :class:`BaseLexer`.&quot;&quot;&quot;</span>
        <span class="c1"># Assign the passed parameters.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">state_map</span> <span class="o">=</span> <span class="n">state_map</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">symbol_map</span> <span class="o">=</span> <span class="n">symbol_map</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">bracket_states</span> <span class="o">=</span> <span class="n">_mutable</span><span class="p">(</span><span class="n">bracket_states</span><span class="p">,</span> <span class="nb">dict</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">bracket_ends</span> <span class="o">=</span> <span class="n">_mutable</span><span class="p">(</span><span class="n">bracket_ends</span><span class="p">,</span> <span class="nb">dict</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">result_map</span> <span class="o">=</span> <span class="n">_mutable</span><span class="p">(</span><span class="n">result_map</span><span class="p">,</span> <span class="nb">dict</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">no_store</span> <span class="o">=</span> <span class="n">_mutable</span><span class="p">(</span><span class="n">no_store</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">init_state</span> <span class="o">=</span> <span class="n">init_state</span>

        <span class="c1"># Assign internal attributes.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">state</span> <span class="o">=</span> <span class="n">init_state</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">process</span><span class="p">:</span> <span class="n">StateMethod</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_start</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">buffer</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tokens</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="n">TokenInfo</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="c1"># Public methods.</span>
<div class="viewcode-block" id="BaseLexer.lex"><a class="viewcode-back" href="../../lexing.html#yadr.base.BaseLexer.lex">[docs]</a>    <span class="k">def</span> <span class="nf">lex</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">code</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="n">TokenInfo</span><span class="p">,</span> <span class="o">...</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Lex code into tokens for parsing.</span>

<span class="sd">        :param code: A string of code to tranform into tokens.</span>
<span class="sd">        :return: A :class:`tuple` object.</span>
<span class="sd">        :rtype: tuple</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Process each character in the code.</span>
        <span class="k">for</span> <span class="n">char</span> <span class="ow">in</span> <span class="n">code</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">process</span><span class="p">(</span><span class="n">char</span><span class="p">)</span>

        <span class="c1"># Reset the lexer after processing the string in case the lexer</span>
        <span class="c1"># is reused.</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_change_state</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">init_state</span><span class="p">,</span> <span class="s1">&#39;&#39;</span><span class="p">)</span>

        <span class="c1"># Return the tokens from the code.</span>
        <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tokens</span><span class="p">)</span></div>

    <span class="c1"># Private operation method.</span>
    <span class="k">def</span> <span class="nf">_is_token_start</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">token</span><span class="p">:</span> <span class="n">Token</span><span class="p">,</span> <span class="n">char</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Is the given character the start of a new token.&quot;&quot;&quot;</span>
        <span class="n">valid</span> <span class="o">=</span> <span class="p">{</span><span class="n">s</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">symbol_map</span><span class="p">[</span><span class="n">token</span><span class="p">]}</span>
        <span class="k">return</span> <span class="n">char</span> <span class="ow">in</span> <span class="n">valid</span>

    <span class="k">def</span> <span class="nf">_is_token_still</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">char</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Is the given character still a part of the current token.&quot;&quot;&quot;</span>
        <span class="n">index</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">buffer</span><span class="p">)</span>
        <span class="n">tokens</span> <span class="o">=</span> <span class="p">[</span><span class="n">t</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">symbol_map</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">state</span><span class="p">]</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">index</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">tokens</span><span class="p">:</span>
            <span class="n">valid</span> <span class="o">=</span> <span class="p">{</span><span class="n">s</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">tokens</span><span class="p">}</span>
            <span class="k">return</span> <span class="n">char</span> <span class="ow">in</span> <span class="n">valid</span>
        <span class="k">return</span> <span class="kc">False</span>

    <span class="k">def</span> <span class="nf">_cannot_follow</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">char</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;The character is not allowed by the current state.&quot;&quot;&quot;</span>
        <span class="n">state</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">state</span><span class="o">.</span><span class="n">name</span>
        <span class="k">if</span> <span class="n">state</span> <span class="o">==</span> <span class="s1">&#39;WHITESPACE&#39;</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">tokens</span><span class="p">:</span>
            <span class="n">state</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tokens</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">name</span>
        <span class="k">elif</span> <span class="n">state</span> <span class="o">==</span> <span class="s1">&#39;WHITESPACE&#39;</span><span class="p">:</span>
            <span class="n">state</span> <span class="o">=</span> <span class="s1">&#39;START&#39;</span>
        <span class="k">if</span> <span class="n">state</span> <span class="o">==</span> <span class="s1">&#39;QUALIFIER_END&#39;</span><span class="p">:</span>
            <span class="n">state</span> <span class="o">=</span> <span class="s1">&#39;QUALIFIER&#39;</span>
        <span class="k">if</span> <span class="n">state</span> <span class="o">==</span> <span class="s1">&#39;NUMBER&#39;</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">buffer</span> <span class="o">==</span> <span class="s1">&#39;-&#39;</span><span class="p">:</span>
            <span class="n">state</span> <span class="o">=</span> <span class="s1">&#39;NEGATIVE_SIGN&#39;</span>

        <span class="k">if</span> <span class="n">state</span> <span class="o">==</span> <span class="s1">&#39;START&#39;</span><span class="p">:</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="sa">f</span><span class="s1">&#39;Cannot start with </span><span class="si">{</span><span class="n">char</span><span class="si">}</span><span class="s1">.&#39;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">article</span> <span class="o">=</span> <span class="s1">&#39;a&#39;</span>
            <span class="k">if</span> <span class="n">state</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">in</span> <span class="s1">&#39;AEIOU&#39;</span><span class="p">:</span>
                <span class="n">article</span> <span class="o">=</span> <span class="s1">&#39;an&#39;</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">char</span><span class="si">}</span><span class="s1"> cannot follow </span><span class="si">{</span><span class="n">article</span><span class="si">}</span><span class="s1"> </span><span class="si">{</span><span class="n">state</span><span class="si">}</span><span class="s1">.&#39;</span>

        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_change_state</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">new_state</span><span class="p">:</span> <span class="n">Token</span><span class="p">,</span> <span class="n">char</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Terminate the previous token and start a new one.&quot;&quot;&quot;</span>
        <span class="c1"># Terminate and store the old token.</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">state</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">no_store</span><span class="p">:</span>
            <span class="n">value</span><span class="p">:</span> <span class="n">Result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">buffer</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">state</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">result_map</span><span class="p">:</span>
                <span class="n">transform</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">result_map</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">state</span><span class="p">]</span>
                <span class="n">value</span> <span class="o">=</span> <span class="n">transform</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
            <span class="n">token_info</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">state</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">tokens</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">token_info</span><span class="p">)</span>

        <span class="c1"># Set new state.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">buffer</span> <span class="o">=</span> <span class="n">char</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">state</span> <span class="o">=</span> <span class="n">new_state</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">process</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">state_map</span><span class="p">[</span><span class="n">new_state</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">_check_char</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">char</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">can_follow</span><span class="p">:</span> <span class="nb">list</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Determine how to process a character.&quot;&quot;&quot;</span>
        <span class="n">new_state</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Token</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="c1"># If the character doesn&#39;t change the state, add it to the</span>
        <span class="c1"># buffer and stop processing.</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_token_still</span><span class="p">(</span><span class="n">char</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">buffer</span> <span class="o">+=</span> <span class="n">char</span>
            <span class="k">return</span> <span class="kc">None</span>

        <span class="c1"># Check to see if the character starts a token that is allowed</span>
        <span class="c1"># to follow the current token. Stop looking once you find one.</span>
        <span class="k">for</span> <span class="n">token</span> <span class="ow">in</span> <span class="n">can_follow</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_token_start</span><span class="p">(</span><span class="n">token</span><span class="p">,</span> <span class="n">char</span><span class="p">):</span>
                <span class="n">new_state</span> <span class="o">=</span> <span class="n">token</span>
                <span class="k">break</span>

        <span class="c1"># If not, throw an exception. Since whitespace isn&#39;t a token in</span>
        <span class="c1"># YADN, an exception saying a character can&#39;t follow WHITESPACE</span>
        <span class="c1"># isn&#39;t useful. Therefore handle that case by looking at the</span>
        <span class="c1"># last stored token.</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_cannot_follow</span><span class="p">(</span><span class="n">char</span><span class="p">)</span>

        <span class="c1"># Some tokens start a state that doesn&#39;t match the token.</span>
        <span class="k">if</span> <span class="n">new_state</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">bracket_states</span><span class="p">:</span>
            <span class="n">new_state</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bracket_states</span><span class="p">[</span><span class="n">new_state</span><span class="p">]</span>

        <span class="c1"># Catch an attempt to end a number when the only character is</span>
        <span class="c1"># negative sign.</span>
        <span class="k">if</span> <span class="n">new_state</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">state</span> <span class="o">==</span> <span class="n">Token</span><span class="o">.</span><span class="n">NUMBER</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">buffer</span> <span class="o">==</span> <span class="s1">&#39;-&#39;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_cannot_follow</span><span class="p">(</span><span class="n">char</span><span class="p">)</span>

        <span class="c1"># If the state changed, change the state.</span>
        <span class="k">if</span> <span class="n">new_state</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_change_state</span><span class="p">(</span><span class="n">new_state</span><span class="p">,</span> <span class="n">char</span><span class="p">)</span>

    <span class="c1"># Lexing rules.</span>
    <span class="nd">@abstractmethod</span>
    <span class="k">def</span> <span class="nf">_start</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">char</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;An abstract method for the processing method used for the</span>
<span class="sd">        initial state of the lexer.</span>

<span class="sd">        :param char: The character currently being lexed.</span>
<span class="sd">        :return: None</span>
<span class="sd">        :rtype: NoneType</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># The tokens that are allowed to follow the current state.</span>
        <span class="n">can_follow</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="n">Token</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="c1"># Check to see if the current character causes the lexer</span>
        <span class="c1"># to change state.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_check_char</span><span class="p">(</span><span class="n">char</span><span class="p">,</span> <span class="n">can_follow</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_whitespace</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">char</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Lex white space.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">char</span><span class="o">.</span><span class="n">isspace</span><span class="p">():</span>
            <span class="k">return</span> <span class="kc">None</span>
        <span class="n">prev_state</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">init_state</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">tokens</span><span class="p">:</span>
            <span class="n">prev_state</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tokens</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">prev_state</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">bracket_ends</span><span class="p">:</span>
            <span class="n">prev_state</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bracket_ends</span><span class="p">[</span><span class="n">prev_state</span><span class="p">]</span>
        <span class="n">process</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">state_map</span><span class="p">[</span><span class="n">prev_state</span><span class="p">]</span>
        <span class="n">process</span><span class="p">(</span><span class="n">char</span><span class="p">)</span></div>
</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2023, Paul J. Iutzi.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>